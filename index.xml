<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Luckywinds</title>
    <link>https://luckywinds.github.io/</link>
    <description>Recent content on Luckywinds</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 15 Mar 2020 18:07:32 +0800</lastBuildDate>
    
	<atom:link href="https://luckywinds.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Pilot Discovery</title>
      <link>https://luckywinds.github.io/posts/sourcecode/istio/pilot-discovery/</link>
      <pubDate>Sun, 15 Mar 2020 18:07:32 +0800</pubDate>
      
      <guid>https://luckywinds.github.io/posts/sourcecode/istio/pilot-discovery/</guid>
      <description>入口 pilot/cmd/pilot-discovery/main.go
 init()，初始化参数并设置默认值，初始化标识符等 main()，启动server  bootstrap </description>
    </item>
    
    <item>
      <title>Dockerfile简介</title>
      <link>https://luckywinds.github.io/posts/opensource/dockerfile/</link>
      <pubDate>Sun, 08 Mar 2020 18:07:32 +0800</pubDate>
      
      <guid>https://luckywinds.github.io/posts/opensource/dockerfile/</guid>
      <description>&lt;h2 id=&#34;linux文件系统&#34;&gt;Linux文件系统&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://luckywinds.github.io/images/posts/opensource/dockerfile-os-fs.png&#34; alt=&#34;alt&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;典型的Linux文件系统由bootfs和rootfs两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bootfs(boot file system)，只读层，主要包含bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后bootfs就被umount了。&lt;/li&gt;
&lt;li&gt;rootfs(root file system)，读写层，包含的就是典型的/dev，/proc，/bin，/etc等标准目录和文件。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes网络</title>
      <link>https://luckywinds.github.io/posts/opensource/kubernetes-network/</link>
      <pubDate>Sun, 01 Mar 2020 18:07:32 +0800</pubDate>
      
      <guid>https://luckywinds.github.io/posts/opensource/kubernetes-network/</guid>
      <description>&lt;h2 id=&#34;规则&#34;&gt;规则&lt;/h2&gt;
&lt;p&gt;Kubernetes规定网络需要满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有Pod之间可以互通，不能通过NAT&lt;/li&gt;
&lt;li&gt;所有Node和Pod之间可以互通，不能通过NAT&lt;/li&gt;
&lt;li&gt;每个Pod拥有唯一的IP&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes简介</title>
      <link>https://luckywinds.github.io/posts/opensource/kubernetes/</link>
      <pubDate>Sun, 01 Mar 2020 16:07:32 +0800</pubDate>
      
      <guid>https://luckywinds.github.io/posts/opensource/kubernetes/</guid>
      <description>&lt;h2 id=&#34;环境准备&#34;&gt;环境准备&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.play-with-k8s.com/&#34;&gt;https://labs.play-with-k8s.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Iptables简介</title>
      <link>https://luckywinds.github.io/posts/tips/iptables/</link>
      <pubDate>Sun, 01 Mar 2020 11:24:16 +0800</pubDate>
      
      <guid>https://luckywinds.github.io/posts/tips/iptables/</guid>
      <description>&lt;h2 id=&#34;工作流&#34;&gt;工作流&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://luckywinds.github.io/images/posts/tips/iptables-tables-traverse.jpg&#34; alt=&#34;alt&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Iptables由表、链和规则组成，从任何网络端口进来的每一个IP数据包都要从上到下的穿过这张图，在大多数使用情况下都不会用到raw和mangle表&lt;/p&gt;
&lt;p&gt;表包含链，链包含规则。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tomcat简介</title>
      <link>https://luckywinds.github.io/posts/opensource/tomcat/</link>
      <pubDate>Sun, 01 Mar 2020 11:24:16 +0800</pubDate>
      
      <guid>https://luckywinds.github.io/posts/opensource/tomcat/</guid>
      <description>&lt;h2 id=&#34;整体架构&#34;&gt;整体架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://luckywinds.github.io/images/posts/opensource/tomcat-overview.PNG&#34; alt=&#34;alt&#34; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server：代表整个Tomcat，控制Tomcat自身的生命周期&lt;/li&gt;
&lt;li&gt;Service：对外提供的服务，由多个Connector和一个Container组成&lt;/li&gt;
&lt;li&gt;Connector：服务的入口，用于处理连接相关的事情，并提供Socket与Request和Response相关的转化&lt;/li&gt;
&lt;li&gt;Container：提供实际的服务能力，用于封装和管理Servlet，以及具体处理Request请求&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>OS问题定位技巧</title>
      <link>https://luckywinds.github.io/posts/debug/os_problem/</link>
      <pubDate>Sun, 23 Feb 2020 14:09:21 +0900</pubDate>
      
      <guid>https://luckywinds.github.io/posts/debug/os_problem/</guid>
      <description>&lt;h2 id=&#34;cpu&#34;&gt;CPU&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;top&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://luckywinds.github.io/images/posts/debug/os-problem-top.PNG&#34; alt=&#34;alt&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;关键点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键入M，按进程内存占用大小排序&lt;/li&gt;
&lt;li&gt;键入P，按进程CPU占用大小排序&lt;/li&gt;
&lt;li&gt;观察Cpu(s)：id值，空闲CPU时间百分比，值过低，表明系统CPU存在瓶颈&lt;/li&gt;
&lt;li&gt;观察Cpu(s)：wa值，等待I/O的CPU时间百分比，值过高，表明IO存在瓶颈&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Java：双重检查锁定模式</title>
      <link>https://luckywinds.github.io/posts/tips/java-double-checked-locking/</link>
      <pubDate>Sun, 23 Feb 2020 11:24:16 +0800</pubDate>
      
      <guid>https://luckywinds.github.io/posts/tips/java-double-checked-locking/</guid>
      <description>&lt;p&gt;首先验证锁定条件(第一次检查)，只有通过锁定条件验证才真正的进行加锁逻辑并再次验证条件(第二次检查)&lt;/p&gt;
&lt;p&gt;用来减少并发系统中竞争和同步的开销&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/algorithm/graph/bfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/algorithm/graph/bfs/</guid>
      <description>BFS  广度优先搜索
 简介 应用：最短路径
代码 class BFS:def __init__(self, graph: Graph, source: int):self.marked = [False] * graph.vself.edge_to = [i for i in range(graph.v)]self.dist_to = [-1] * graph.vself.graph = graphself.source = sourceself.__validate_v(source)self.__bfs(graph, source)def __validate_v(self, v):if v &amp;lt; 0 or v &amp;gt;= self.graph.v:raise Exception(&amp;#34;{} illegal&amp;#34;.format(v))def __bfs(self, graph, v):q = [v]self.marked[v] = Trueself.dist_to[v] = 0while len(q) !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/algorithm/graph/dfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/algorithm/graph/dfs/</guid>
      <description>DFS  深度优化搜索
 简介 目标：图的系统化搜索，模仿迷宫探索式搜索
应用：
 根据一个点，找到所有关联的点 判断两个点之间是否可达   两点之间搜索路径不唯一
 代码 class DFS:def __init__(self, graph: Graph, source: int):self.marked = [False] * graph.vself.edge_to = [i for i in range(graph.v)]self.source = sourceself.graph = graphself.cnt = 0self.__validate_v(source)self.__dfs(graph, source)def __validate_v(self, v):if v &amp;lt; 0 or v &amp;gt;= self.graph.v:raise Exception(&amp;#34;{} illegal&amp;#34;.format(v))def __dfs(self, graph, v):self.marked[v] = Trueself.cnt += 1for w in graph.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/algorithm/graph/graph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/algorithm/graph/graph/</guid>
      <description>无向图 表示 通过符号表，将名称转换成序号，达到通用图表示的目的
问题 路径：
 s和t之间是否可达路径（DFS，BFS） s和t之间的最短路径（BFS）  环路：
 图中是否存在环路 是否存在一个环路经过图上所有点并且只路过一次 是否存在一个环路经过图上所有边并且只路过一次  连接：
 图上所有点是否可以全部连接在一起（DFS，BFS） 最佳的方法是什么？最小生成树 是否能够删除一个点将图一分为二？割点  平面度：
 是否可以不跨边画出同构图？ 两个邻接列表是否可以表示同一个图？  邻接矩阵  采用二维bool数组，表示i和j之间是否存在边
 邻接表  采用二维list数组，表示i和i所有边的对应关系
 class Graph:def __init__(self, v):self.v = vself.e = 0self.adj = [[] for i in range(v)]def get_v(self):return self.vdef get_e(self):return self.edef __validate_v(self, v):if v &amp;lt; 0 or v &amp;gt;= self.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/algorithm/priorityqueues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/algorithm/priorityqueues/</guid>
      <description>优先级队列 应用场景  数据流中最大/小N元素判断 图搜索 &amp;hellip;  Code class MaxPQ:def __init__(self):self.key = [0]self.len = 0def empty(self):return self.len == 0def insert(self, k):self.key.append(k)self.len += 1self.swim(self.len)def del_max(self):m = self.key[1]self.swap(1, self.len)del self.key[self.len]self.len -= 1self.sink(1)return mdef swim(self, k):while k &amp;gt; 1 and self.less(int(k / 2), k):self.swap(k, int(k / 2))k = int(k / 2)def sink(self, k):while 2 * k &amp;lt;= self.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/algorithm/recursion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/algorithm/recursion/</guid>
      <description>递归 思路 某个函数直接或者间接地调用自己，把原问题的求解转换为许多性质相同但是规模更小的子问题。
重点关注如何把原问题划分成符合条件的子问题，以及最简问题的求解。
套路 int func(问题规模) {if (终止条件) {return 最小子问题解;}return func(缩小规模);} 问题规模通常包含数据和其当前状态
 优化  所谓的剪枝，即提前判断当前状态是否有必要继续分解下去而提前结束
 备忘录 int memo[MAX]int func(问题规模) {if (memo[当前状态]) {return 当前问题解}if (终止条件) {return 最小子问题解;}return func(缩小规模);} 定义备忘录，记录问题状态和其对应的解 判断当前状态是否在备忘录中，提前返回解（有解和无解）  最优化 int ans；//当前最差状态int func(问题规模) {if (当前状态 比 ans 更差) {return 无解}if (终止条件) {return 最小子问题解;}return func(缩小规模);} 定义临时状态，记录当前最差状态 判断当前状态是否比最差状态还差或者直接不可用，提前返回解（无解）  示例 力扣1137.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/algorithm/string/kmp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/algorithm/string/kmp/</guid>
      <description>KMP 应用场景：字符串匹配及扩展场景
原理 例：字符串&amp;quot;BBC ABCDAB ABCDABCDABDE&amp;quot;是否包含&amp;quot;ABCDABD&amp;rdquo;
假设已经匹配到当前位置
正常情况下，将目标串右移一位继续进行比较匹配
简单识别后，会发现下一次有意义的比较是将目标串右移4位再进行比较
KMP算法的核心就是如何快速找到下一次有意义的右移，避免无意义的比较，来提高效率
KMP算法，通过构建辅助表（又叫部分匹配表），表中数据表示，当前位置最长“前缀”和“后缀”相同的长度，以前6个字符“ABCDAB”为例
 相同的最长“前缀”和“后缀”是“AB”，所以第6位是2 假设已经匹配到“ABCDAB”前6个字符串，但是第7个字符“D”发现不匹配，这时候前4个字符“ABCD”已经没有比较意义 直接将目标串跳过“ABCD”，右移4位继续比较即可  部分匹配表 例：目标串是“ACABACACD”
i，表示当前处理的位置 m，表示最长“前缀”和“后缀”的长度
def createPMT(self, w):aux = [0] * len(w)i = 1m = 0while i &amp;lt; len(w):if w[i] == w[m]:m += 1aux[i] = mi += 1elif w[i] != w[m] and m != 0:m = aux[m-1]else:aux[i] = 0i += 1return aux关键点：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/algorithm/unionfind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/algorithm/unionfind/</guid>
      <description>并查集 应用场景  照片中的像素 网络中的计算机 社交网络的朋友 等  Code class UnionFind:def __init__(self, n):self.id = [i for i in range(n)]self.size = [1] * ndef root(self, i):while i != self.id[i]:self.id[i] = self.id[self.id[i]]i = self.id[i]return idef connected(self, p, q):return self.root(p) == self.root(q)def union(self, p, q):i = self.root(p)j = self.root(q)if i == j:returnif self.size[i] &amp;lt; self.size[j]:self.id[i] = jself.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/language/go-goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/language/go-goroutine/</guid>
      <description>Go 并发 Goroutine  协程，轻量级线程，包括匿名协程和命名协程
 func main() {go test1()go func() {fmt.Println(&amp;#34;Hello&amp;#34;)}()}func test1() {fmt.Println(&amp;#34;Hello&amp;#34;)} 无法获取协程结束标识
 互斥  协程之间通过Channel进行通信
 单任务 func test2() {done := make(chan bool)go func(){fmt.Println(&amp;#34;Hello&amp;#34;)done &amp;lt;- true}()&amp;lt;-done} 无缓冲Channel，接收动完成生在对Channel的发送完成之前。
 多任务 Channel func test3() {done := make(chan bool, 3)for i := 0; i &amp;lt; cap(done); i++ {go func(){fmt.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/language/go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/language/go/</guid>
      <description>Go import语法 ImportDeclaration = &amp;quot;import&amp;quot; ImportSpecImportSpec = [ &amp;quot;.&amp;quot; | &amp;quot;_&amp;quot; | Identifier ] ImportPath .: 匿名别名，可以直接使用包的方法，无需指定包名 _: 仅使用包的init函数，其他方法不使用 Identifier: 显式别名，代替原始包名字  示例：
import (&amp;quot;math&amp;quot;m &amp;quot;math&amp;quot;. &amp;quot;math&amp;quot;_ &amp;quot;math&amp;quot;&amp;quot;go.etcd.io/etcd/clientv3&amp;quot;) 短路径：标准库，例如：&amp;ldquo;math&amp;rdquo; 长路径：第三方库，例如：&amp;ldquo;go.etcd.io/etcd/clientv3&amp;rdquo;  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/language/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/language/java/</guid>
      <description>Java 工具 基础工具：
appletviewer	Run and debug applets without a web browser.extcheck	Utility to detect Jar conflicts.jar	Create and manage Java Archive (JAR) files.java	The launcher for Java applications. In this release, a single launcher is used both for development and deployment.javac	The compiler for the Java programming language.javadoc	API documentation generator.javah	C header and stub generator. Used to write native methods.javap	Class file disassemblerjdb	The Java Debugger.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/language/python/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/language/python/</guid>
      <description>Python 内置数据类型 内置类型：
类型转换：
 str(x) int(x) float(x) round(x)  内置数据结构  List(as Stacks Queues)，[]，可变序列 Tuples，()，不可变序列 Sets，{}，无序，唯一 Dicts，{}，键值对，键唯一  List生成式 直接生成：
&amp;gt;&amp;gt;&amp;gt; list(range(1, 11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]生成后再处理：
&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]生成后再条件处理：
&amp;gt;&amp;gt;&amp;gt; [x if x % 2 == 0 else -x for x in range(1, 11)][-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]生成后先过滤再处理：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/language/sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/language/sql/</guid>
      <description>SQL 概述  关系型数据库，主要讨论对表数据查询操作
 语法  Mysql SELECT Syntax Postgres SELECT Syntax SQLite SELECT Syntax Oracle SELECT Syntax  执行逻辑 从源表数据开始，每个执行逻辑基于前面步骤的源表或虚表生成一个新的虚表，将最后的虚表作为结果返回
执行顺序  SQL实际执行顺序并不是按照语法顺序执行的
  FROM：对子句中表执行笛卡尔积，生成虚表VT1。 ON：对VT1应用ON筛选器，生成VT2。 JOIN: 对新表数据按照一定的策略和VT2表中数据进行连接，生成TV3。 WHERE：对VT3应用WHERE筛选器，生成VT4。 GROUP BY：按列对VT4中的行进行分组，生成VT5。 WITH CUTE|ROLLUP：根据聚合策略把聚合数据插入VT5，生成VT6。 HAVING：对VT6应用HAVING筛选器，生成VT7。 SELECT：选择SELECT列表，产生VT8。 DISTINCT：将重复的行从VT8中删除，生成VT9。 ORDER BY：按列进行顺序，生成一个游标(VC10)。 LIMIT(TOP)：从VC10的开始处选择指定数量或比例的行，生成VT11，并作为结果返回。  笛卡尔积  A表m行，B表行，C表k行。笛卡尔积ABC=mnk行数据
 JOIN  先确定基础表，将另外表数据附加到基础表上的过程
  表可以SELECT出来的表
  默认为INNER JOIN
 GROUP BY  如果指定多个列，则按照多个列内容均相同做为分组条件
  聚合函数是按组进行聚合执行的
  SUM	计算合计值，该列必须为数值类型 AVG	计算平均值，该列必须为数值类型 MAX	计算最大值 MIN	计算最小值 COUNT 计数   如果使用了聚合函数但未指定GROUP BY，则默认对整个数据集进行聚合</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/system/service-mesh/istio-bookinfo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/system/service-mesh/istio-bookinfo/</guid>
      <description>理解Bookinfo 资源列表 $ kubectl get svc,pod,gateway,virtualservice -n bookNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/details ClusterIP 10.107.54.71 &amp;lt;none&amp;gt; 9080/TCP 5h14mservice/productpage ClusterIP 10.102.44.220 &amp;lt;none&amp;gt; 9080/TCP 5h14mservice/ratings ClusterIP 10.110.60.146 &amp;lt;none&amp;gt; 9080/TCP 5h14mservice/reviews ClusterIP 10.102.61.22 &amp;lt;none&amp;gt; 9080/TCP 5h14mNAME READY STATUS RESTARTS AGEpod/details-v1-74f858558f-xnvwz 2/2 Running 0 5h14mpod/productpage-v1-76589d9fdc-knv7t 2/2 Running 0 5h14mpod/ratings-v1-7855f5bcb9-blrkh 2/2 Running 0 5h14mpod/reviews-v1-64bc5454b9-6d96p 2/2 Running 0 5h14mpod/reviews-v2-76c64d4bdf-6xmb6 2/2 Running 0 5h14mpod/reviews-v3-5545c7c78f-j8bxg 2/2 Running 0 5h14mNAME AGEgateway.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/system/service-mesh/istio-docker-desktop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/system/service-mesh/istio-docker-desktop/</guid>
      <description>Docker Desktop for Istio 环境 Windows 10
设置vmcompute：
 Windows安全中心 应用和浏览器控制 Exploit Protection 设置 程序设置 vmcompute.exe 编辑 控制流保护(CFG) 替代系统设置，取消勾选 net start vmcompute  Docker Desktop community 2.2.0.4
设置Resources
 ADVANCED：4U8G PROXIES：HTTP和HTTPS，http://docker.for.win.localhost:3128替代http://127.0.0.1:3128 NETWORK：DNS，8.8.8.8 登录Docker Hub 切换Kubernetes至docker-desktop  部署Istio  istio-1.5.1-win.zip
 cd istio-1.5.1 复制bin\istioctl.exe至C:\Program Files\Docker\Docker\resources\bin
 $ istioctl manifest apply --set profile=demoDetected that your cluster does not support third party JWT authentication. Falling back to less secure first party JWT.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/system/service-mesh/istio-observability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/system/service-mesh/istio-observability/</guid>
      <description>理解Istio可观察性 kiali Istio默认自带了Kiali可视化系统
$ istioctl dashboard kiali分布式追踪 分布式追踪可以让用户对跨多个分布式服务网格的 1 个请求进行追踪分析。
Istio 利用 Envoy 的分布式追踪功能提供了开箱即用的追踪集成。
原理：Istio利用应用程序传入请求和传出的请求中的请求头信息，proxy将相关span信息发送至后端服务，然后通过span信息将服务间调用信息串联起来
请求头信息列表：
 x-request-id x-b3-traceid x-b3-spanid x-b3-parentspanid x-b3-sampled x-b3-flags x-ot-span-context  在业务应用中增加信息：
@GET@Path(&amp;quot;/reviews/{productId}&amp;quot;)public Response bookReviewsById(@PathParam(&amp;quot;productId&amp;quot;) int productId,@HeaderParam(&amp;quot;end-user&amp;quot;) String user,@HeaderParam(&amp;quot;x-request-id&amp;quot;) String xreq,@HeaderParam(&amp;quot;x-b3-traceid&amp;quot;) String xtraceid,@HeaderParam(&amp;quot;x-b3-spanid&amp;quot;) String xspanid,@HeaderParam(&amp;quot;x-b3-parentspanid&amp;quot;) String xparentspanid,@HeaderParam(&amp;quot;x-b3-sampled&amp;quot;) String xsampled,@HeaderParam(&amp;quot;x-b3-flags&amp;quot;) String xflags,@HeaderParam(&amp;quot;x-ot-span-context&amp;quot;) String xotspan) {if (ratings_enabled) {JsonObject ratingsResponse = getRatings(Integer.toString(productId), user, xreq, xtraceid, xspanid, xparentspanid, xsampled, xflags, xotspan); Istio默认对每条请求都进行采样，可以通过参数values.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/system/service-mesh/istio-sidecar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/system/service-mesh/istio-sidecar/</guid>
      <description>理解Istio网格中Envoy代理Sidecar Sidecar简介  Sidecar设计模式允许你为应用程序添加许多功能，而无需额外第三方组件的配置和代码的修改。 Sidecar应用是连接到父应用并且为其扩展或者增强功能，可观察性、监控、日志记录、配置、断路器等。 Sidecar应用与主应用程序松散耦合。  注入方式  istio通过修改deployment配置完成相关内容注入
 k8s自动注入  Kubernetes通过Admission Controller可以拦截所有发往Api server的请求 Istio通过MutatingAdmissionWebhook（变更类型Admission Controller）完成对deployment的请求修改 自定义配置通过ConfigMap获取  $ kubectl get configmap istio-sidecar-injector -n istio-systemNAME DATA AGEistio-sidecar-injector 2 28histioctl手工注入 istioctl kube-inject -f samples/sleep/sleep.yaml | kubectl apply -f -
注入内容 Istio sidecar向应用pod中注入2个容器：
 init，初始化Envoy环境，配置iptables规则，拦截所有进出口流量至proxy istio-proxy，Envoy代理，运行pilot-agent和envoy进程   Pilot-agent负责管理Envoy进程，重启、静态配置热加载等 Envoy动态配置通过xDS更新  未注入Sidecar的deployment：
$ kubectl describe pod productpage-v1-76589d9fdc-8wtsk -n book2Name: productpage-v1-76589d9fdc-8wtskNamespace: book2Priority: 0Node: docker-desktop/192.168.65.3Start Time: Sat, 04 Apr 2020 15:08:29 +0800Labels: app=productpagepod-template-hash=76589d9fdcversion=v1Annotations: &amp;lt;none&amp;gt;Status: RunningIP: 10.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/system/service-mesh/istio-traffic-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/system/service-mesh/istio-traffic-management/</guid>
      <description>理解Istio流量管理  参考官网：https://istio.io/zh/docs/tasks/traffic-management/
 Istio核心概念：
 Gateway定义服务出入口 Virtual Service定义服务路由策略 Destination Rule定义服务子集、负载均衡、连接池等信息  Envoy核心概念：
 Listener，监听器，命名网地址可以被下游客户端连接，由LDS提供动态配置接口 Router，路由，一组将虚拟主机(virtual hosts)与群集(cluster)匹配的规则(rule)，允许创建流量转移规则，由RDS提供动态配置接口 Cluster，集群，指Envoy连接到的逻辑上相同的一组上游主机，由CDS提供动态配置接口 Endpoint，端点，群集(Cluster)中可用的IP和端口，由EDS提供动态配置接口  原理：Istio配置下发后，转换为Envoy配置后在proxy上生效，实现Istio策略下发，Envoy流量控制，完成整体服务网格流量管理
配置请求路由 设置服务集、路由
$ kubectl apply -f samples/bookinfo/networking/destination-rule-all.yaml -n bookdestinationrule.networking.istio.io/productpage createddestinationrule.networking.istio.io/reviews createddestinationrule.networking.istio.io/ratings createddestinationrule.networking.istio.io/details created$ kubectl apply -f samples/bookinfo/networking/virtual-service-all-v1.yaml -n bookvirtualservice.networking.istio.io/productpage createdvirtualservice.networking.istio.io/reviews createdvirtualservice.networking.istio.io/ratings createdvirtualservice.networking.istio.io/details created destination-rule-all.yaml，根据pod的标签version值划分服务子集 virtual-service-all-v1.yaml，定义路径策略，将各服务请求默认路由至v1版本  Virtual Service如果关联了Gateway则同时在具体ingressgateway的proxy上生效，用于服务入口控制，例如productpage
apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:name: productpage...spec:gateways:- bookinfo-gateway- meshhosts:- productpagehttp:- route:- destination:host: productpagesubset: v1$ istioctl proxy-config route reviews-v1-64bc5454b9-6d96p -n book -o json --name 9080.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/system/service-mesh/istio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/system/service-mesh/istio/</guid>
      <description>Istio简介  Istio是service mesh的一种
 核心特性  流量管理：限流、熔断、故障注入等 安全：认证、授权、加密等 监测：跟踪、监控、日志等  架构 Istio逻辑上分为数据面（data plane）和控制面（control plane）
 数据面：由sidecar模式部署的Envoy代理组成，控制微服务之间的网络通信 控制面：管理和配置sidecar代理服务上  组件：
 Envoy：高性能的代理服务，代理微服务所有的出入流量 Pilot：服务发现、智能路由、网络韧性（超时、重试、熔断等） Citadel：安全管理 Galley：策略管理   Polit通过调用第三方云平台（k8s等）接口获取服务发现能力 Polit提供接口支持外部服务配置，和第三方云平台服务发现的内容，一起抽象出Istio自己的服务模型 Polit适配Envoy提供xDS（LDS、RDS、CDS、EDS等）服务接口，支持配置动态能力  组件  istio-citadel，安全管理 istio-galley，配置管理 istio-pilot，服务发现、智能路由、策略控制 istio-ingressgateway，入口管理 istio-egressgateway，出口管理 istio-policy，访问控制管理 istio-telemetry，服务监测管理 istio-sidecar-injector，代理管理  网络  外部流量通过Gateway进入集群，提供基本控制能力，例如port、tls、limit等 通过Virtual Service实现不同版本的Service服务路由能力，例如headers/url/weight等，支持蓝绿、金丝雀、故障注入等能力 Service内部支持LB负载配置，精确控制各实例访问控制策略  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/system/system-design-primer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/system/system-design-primer/</guid>
      <description>系统设计入门 概览  DNS，第一层路由 CDN，第二层缓存 LB，第三层负载 Web Server和API，前后分离 Queue，消息队列 Cache，缓存 SQL，读写分离 NoSql，对象存储  DNS 域名结构：
 分层管理
 域名解析：
递归：
迭代：
资源类型：
 NS 记录（域名服务） ─ 指定解析域名或子域名的DNS服务器。 MX 记录（邮件交换） ─ 指定接收信息的邮件服务器。 A 记录（地址） ─ 指定域名对应的IP地址记录。 CNAME（规范） ─ 一个域名映射到另一个域名或CNAME记录（example.com指向www.example.com）或映射到一个A记录。  优缺点：
 延迟 DDOS 不可或缺  CDN 作用：
CDN是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由CDN提供。
 从靠近用户的数据中心提供资源 通过CDN，服务器不必真的处理请求  内容更新模式：
 推送（push）：服务器上内容发生变动时，推送新内容给CDN，并重写URL地址以指向新内容的CDN地址。流量最小化，但储存最大化。 拉取（pull）：当第一个用户请求该资源时，从服务器上拉取资源，存活时间（TTL）决定缓存多久时间。最小化储存空间，有冗余流量。适合高流量站点  优缺点：
 减低服务请求压力 流量贵 过期，内容更新  LB  LB和Proxy，在大多场景基本是等效的，LB可以运行在Proxy模式，Proxy可以提供LB功能
 特性：
主要任务：
 位于客户端和服务端之间</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/tool/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/tool/git/</guid>
      <description>Git 概述 3+1棵树
 Workspace：工作目录，持有实际工作文件 Index：暂存区，临时保存工作文件变更情况 Repository：本地仓库，在本地保存完整Git记录 Remote：远端仓库，实际代码仓库   所有的Git操作，都是文件变化记录在这四棵树之间流转，开发过程中重点关注前3棵树
 获取代码库  git clone [url]，克隆到本地，文件夹名字和仓库名字保持一致 git clone [url] local_dir，克隆到本地，文件夹名字自定义   url可以是git://或ssh://或http(s)://或ftp://等
 查看分支 git branch &amp;lt;options&amp;gt;
 无选项，列出本地分支 -a，列出本地分支和远程分支 -r，列出远程分支  git tag
 列出标签列表
 分支管理  git branch dev，基于当前分支创建dev分支 git checkout dev，切换到dev分支 git branch -d dev，删除分支 git checkout -b dev [origin/branch|tag]，基于指定分支或标签，创建并切换分支  获取更新信息  git fetch &amp;lt;origin&amp;gt; &amp;lt;branch&amp;gt;   仅获取指定分支的更新信息，不合并内容
  获取的分支名字规则为origin/branch
  git pull &amp;lt;origin&amp;gt; &amp;lt;branch&amp;gt;   获取指定分支的更新信息，自动合并更新到本地当前分支</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/tool/maven/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/tool/maven/</guid>
      <description>Maven 坐标 &amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt; groupId，定义当前模块隶属的实际Maven项目 artifactId，定义实际项目中的一个Maven模块 version，定义当前项目所处版本，版本号定义约定: &amp;lt;主版本&amp;gt;.&amp;lt;次版本&amp;gt;.&amp;lt;增量版本&amp;gt;-&amp;lt;里程碑版本&amp;gt; packaging，定义Maven项目打包方式, 通常打包方式与所生成构件扩展名对应，有jar(默认)、war、pom、maven-plugin等.  依赖  直接依赖 传递依赖，依赖的依赖  版本选择原则：
 路径最近者优先 第一声明者优先  依赖除了保护坐标信息外，还保护以下内容：
 scope，用来控制依赖与三种classpath(编译classpath、测试classpath、运行classpath)的关系，包含compile、provided、runtime、test、system和import optional，依赖是否可选 exclusions，排除传递性依赖  查看依赖树：mvn dependency:tree
仓库  集中存储这些构件的地方
   本地仓库: 默认地址为~/.m2/, 一个构件只有在本地仓库存在之后, 才能由Maven项目使用
  远程仓库: 远程仓库又可简单分成两类: 中央仓库和私服（代理仓库）
  repository表示发布版本构件的仓库
  snapshotRepository代表快照版本的仓库
  生命周期与插件  clean：pre-clean、clean、post-clean default：process-resources、compile、process-test-resources、test-compile、test、package、install、deploy site：pre-site、site、post-site、site-deploy  生命周期的阶段phase与插件的目标goal相互绑定, 用以完成实际的构建任务
mvn compile:compile，冒号前是插件前缀, 后面是该插件目标
聚合继承 通过在一个打包方式为pom的Maven项目中声明任意数量的module以实现模块聚合 聚合POM放在项目目录的最顶层, 其他模块作为聚合模块的子目录 聚合POM存放公共配置，子模块POM存放定制化配置</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luckywinds.github.io/docs/tool/uml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luckywinds.github.io/docs/tool/uml/</guid>
      <description>UML UML类图  理解类之间的关系，统一符号意义，提高工作交流效率
 记住三个重要符号：三角形、菱形、尖括号，每个符号分为虚实两类，实虚代表类之间的强弱关系
三角形  实线，继承关系   理解要点：实实在在的类，不玩虚的
 例如，SUV和小汽车，都是独立存在的实体
 虚线，实现关系   理解要点：就玩虚的，实现接口或继承抽象类
 例如：小汽车和车，车是抽象的概念
菱形  实心，组合关系   理解要点：大家是不可分割的一体
 例如：发动机和小汽车，没有发动机就不能叫小汽车
 空心，聚合关系   理解要点：大家只是在一起玩
 例如：学生和班级，没有学生，班级照样在哪等着
尖括号  实线，关联关系  理解要点：强关联，成员变量
例如：身份证和学生，每个学生都有身份证
 虚线，依赖关系  理解要点：弱关联，临时变量
例如：学生和自行车，不是每个学生都有自行车
参考：
 看懂UML类图和时序图  </description>
    </item>
    
  </channel>
</rss>